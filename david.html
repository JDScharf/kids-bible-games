<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>David's Sling</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #011627; overflow: hidden; font-family: 'Georgia', serif; }
  canvas { display: block; }
  #ui {
    position: fixed; top: 0; left: 0; right: 0;
    display: flex; justify-content: space-between; align-items: center;
    padding: 16px 28px; pointer-events: none; z-index: 10;
  }
  #score-box {
    background: rgba(1,22,39,0.75); border: 2px solid #2ec4b6;
    border-radius: 12px; padding: 8px 22px; color: #2ec4b6;
    font-size: 1.5rem; font-weight: bold; letter-spacing: 1px;
  }
  #title-box {
    color: #fdfffc; font-size: 1.4rem; text-align: center;
    text-shadow: 0 2px 8px #000;
  }
  #title-box span { color: #ff9f1c; }
  #stones-box {
    background: rgba(1,22,39,0.75); border: 2px solid #2ec4b6;
    border-radius: 12px; padding: 8px 18px; color: #fdfffc;
    font-size: 1.2rem;
  }
  #msg {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
    background: rgba(1,22,39,0.92); border: 3px solid #2ec4b6;
    border-radius: 20px; padding: 32px 48px; color: #fdfffc;
    font-size: 2rem; text-align: center; z-index: 20;
    display: none; pointer-events: none;
  }
  #msg .big { font-size: 3rem; color: #ff9f1c; display: block; margin-bottom: 8px; }
  #restart {
    position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%);
    background: #ff9f1c; color: #011627; border: none; border-radius: 14px;
    padding: 14px 44px; font-size: 1.4rem; font-family: Georgia, serif;
    font-weight: bold; cursor: pointer; z-index: 20; display: none;
    box-shadow: 0 4px 18px rgba(0,0,0,0.4);
  }
  #aim-hint {
    position: fixed; bottom: 28px; left: 50%; transform: translateX(-50%);
    color: rgba(253,255,252,0.6); font-size: 1rem; z-index: 10; pointer-events: none;
  }
</style>
</head>
<body>
<div id="ui">
  <div id="score-box">Score: <span id="score-val">0</span></div>
  <div id="title-box">â­ <span>David's Sling</span> â­<br><small style="font-size:0.75rem;color:#ccc;">Aim & tap to launch!</small></div>
 <div id="stones-box"><svg width="32" height="32" viewBox="0 0 100 100" style="vertical-align:middle;margin-right:6px"><ellipse cx="50" cy="78" rx="36" ry="10" fill="#7a6040" opacity="0.5"/><polygon points="15,68 10,45 22,28 38,15 58,12 75,22 88,40 85,62 70,72 35,74" fill="#c8a46a"/><polygon points="22,28 38,15 58,12 62,30 45,35 25,40" fill="#d4b47a"/><polygon points="58,12 75,22 88,40 78,38 65,28 62,30" fill="#b8944a"/><polygon points="85,62 70,72 68,55 78,38 88,40" fill="#a07838"/><polygon points="15,68 10,45 22,28 25,40 18,55" fill="#b89458"/><polygon points="38,22 50,18 55,28 42,32" fill="#e0c48a" opacity="0.7"/></svg><span id="stones-val">5</span></div>
</div>
<div id="msg"><span class="big" id="msg-title">Well done!</span><span id="msg-body"></span></div>
<button id="restart" onclick="restartGame()">Play Again!</button>
<div id="aim-hint" id="hint">Press & drag to aim, release to fire</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// â”€â”€ Scene setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const W = window.innerWidth, H = window.innerHeight;
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(W, H);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB); // midnight
scene.fog = new THREE.Fog(0x87CEEB, 60, 120);

const camera = new THREE.PerspectiveCamera(60, W/H, 0.1, 200);
camera.position.set(0, 3, 14);
camera.lookAt(0, 4, 0);

// Lighting
const ambient = new THREE.AmbientLight(0xffeebb, 0.7);
scene.add(ambient);
const sun = new THREE.DirectionalLight(0xfff5cc, 1.2);
sun.position.set(20, 40, 10);
sun.castShadow = true;
sun.shadow.mapSize.set(1024, 1024);
sun.shadow.camera.near = 0.5;
sun.shadow.camera.far = 100;
sun.shadow.camera.left = -30;
sun.shadow.camera.right = 30;
sun.shadow.camera.top = 30;
sun.shadow.camera.bottom = -30;
scene.add(sun);

// â”€â”€ Ground / Sky environment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ground
const gGeo = new THREE.PlaneGeometry(200, 200);
const gMat = new THREE.MeshLambertMaterial({ color: 0xc8a46a });
const ground = new THREE.Mesh(gGeo, gMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// Hills in background
function makeHill(x, z, r, color) {
  const g = new THREE.SphereGeometry(r, 16, 8, 0, Math.PI*2, 0, Math.PI/2);
  const m = new THREE.MeshLambertMaterial({ color });
  const h = new THREE.Mesh(g, m);
  h.position.set(x, 0, z);
  h.receiveShadow = true;
  scene.add(h);
}
makeHill(-30, -25, 18, 0x8aab5a);
makeHill(28, -30, 22, 0x7a9b4a);
makeHill(0, -40, 25, 0x6a8b3a);

// Decorative rocks/bushes
function addRock(x, y, z, s) {
  const g = new THREE.DodecahedronGeometry(s, 0);
  const m = new THREE.MeshLambertMaterial({ color: 0x888880 });
  const r = new THREE.Mesh(g, m);
  r.position.set(x, y, z);
  r.rotation.set(Math.random(), Math.random(), Math.random());
  r.castShadow = true;
  scene.add(r);
}
[-8,-5,4,9,-12,11].forEach((x,i) => addRock(x, 0.3, -2+i*0.5, 0.3+Math.random()*0.3));

// â”€â”€ Goliath (target dummy) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const goliathGroup = new THREE.Group();
scene.add(goliathGroup);

function makeMesh(geo, color, castShadow=true) {
  const m = new THREE.Mesh(geo, new THREE.MeshLambertMaterial({ color }));
  if (castShadow) m.castShadow = true;
  return m;
}

// Body (wider, taller)
const body = makeMesh(new THREE.CylinderGeometry(1.1, 0.88, 2.9, 12), 0x8B4513);
body.position.y = 2.45;
goliathGroup.add(body);
// Armor plate (large, dark)
const armor = makeMesh(new THREE.BoxGeometry(2.1, 2.1, 0.34), 0x555555);
armor.position.set(0, 2.45, 0.72);
goliathGroup.add(armor);
// Shoulder pads
[-1.15, 1.15].forEach(x => {
  const pad = makeMesh(new THREE.SphereGeometry(0.48, 10, 8), 0x444444);
  pad.scale.set(1, 0.6, 0.9);
  pad.position.set(x, 3.7, 0.1);
  goliathGroup.add(pad);
});
// Head (bigger, darker skin)
const head = makeMesh(new THREE.SphereGeometry(0.8, 12, 10), 0xb87050);
head.position.y = 4.65;
goliathGroup.add(head);
// Helmet (wider, darker)
const helmet = makeMesh(new THREE.CylinderGeometry(0.64, 0.84, 0.56, 12), 0x444444);
helmet.position.y = 5.15;
goliathGroup.add(helmet);
const helmetTop = makeMesh(new THREE.SphereGeometry(0.64, 12, 8, 0, Math.PI*2, 0, Math.PI/2), 0x444444);
helmetTop.position.y = 5.44;
goliathGroup.add(helmetTop);
// Helmet spike
const helmetSpike = makeMesh(new THREE.ConeGeometry(0.14, 0.9, 8), 0x888888);
helmetSpike.position.y = 5.98;
goliathGroup.add(helmetSpike);
// Eyes (menacing deep red)
[-0.3, 0.3].forEach(x => {
  const eye = makeMesh(new THREE.SphereGeometry(0.14, 8, 8), 0x660000);
  eye.position.set(x, 4.76, 0.74);
  goliathGroup.add(eye);
});
// Eyebrows (steep, heavy scowl)
[-0.3, 0.3].forEach((x,i) => {
  const brow = makeMesh(new THREE.BoxGeometry(0.34, 0.12, 0.1), 0x1e1008);
  brow.position.set(x, 5.02, 0.76);
  brow.rotation.z = i===0 ? 0.62 : -0.62;
  goliathGroup.add(brow);
});
// Frown
[-0.2, 0.2].forEach((x,i) => {
  const frown = makeMesh(new THREE.BoxGeometry(0.24, 0.09, 0.09), 0x1e1008);
  frown.position.set(x, 4.32, 0.76);
  frown.rotation.z = i===0 ? -0.55 : 0.55;
  goliathGroup.add(frown);
});
// Arms (massive, spread wide)
[-1.5, 1.5].forEach((x,i) => {
  const arm = makeMesh(new THREE.CylinderGeometry(0.40, 0.32, 2.3, 8), 0x8B4513);
  arm.position.set(x, 2.65, 0);
  arm.rotation.z = x < 0 ? 0.52 : -0.52;
  goliathGroup.add(arm);
});
// Legs (thick, planted)
[-0.52, 0.52].forEach(x => {
  const leg = makeMesh(new THREE.CylinderGeometry(0.38, 0.30, 2.1, 8), 0x6B3410);
  leg.position.set(x, 1.05, 0);
  goliathGroup.add(leg);
});
// Shield (large, battle-worn)
const shield = makeMesh(new THREE.CylinderGeometry(1.05, 1.05, 0.18, 20), 0x7a4a1a);
shield.rotation.z = Math.PI/2;
shield.position.set(-2.1, 2.7, 0.2);
goliathGroup.add(shield);
// Shield center boss
const shieldBoss = makeMesh(new THREE.SphereGeometry(0.24, 8, 8), 0x999999);
shieldBoss.rotation.z = Math.PI/2;
shieldBoss.position.set(-2.12, 2.7, 0.2);
goliathGroup.add(shieldBoss);
// Spear (long, thick)
const spearHandle = makeMesh(new THREE.CylinderGeometry(0.1, 0.1, 5.8, 8), 0x7a5810);
spearHandle.position.set(1.55, 3.6, 0);
goliathGroup.add(spearHandle);
const spearTip = makeMesh(new THREE.ConeGeometry(0.28, 0.95, 8), 0xbbbbbb);
spearTip.position.set(1.55, 6.7, 0);
goliathGroup.add(spearTip);

goliathGroup.position.set(0, 0, -10);
goliathGroup.scale.setScalar(1.7);


// â”€â”€ Stars (hit effect) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const stars = [];
function spawnStars(pos) {
  for (let i = 0; i < 12; i++) {
    const g = new THREE.SphereGeometry(0.15, 6, 6);
    const m = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(Math.random(), 1, 0.6) });
    const s = new THREE.Mesh(g, m);
    s.position.copy(pos);
    const v = new THREE.Vector3((Math.random()-0.5)*8, Math.random()*6+2, (Math.random()-0.5)*4);
    scene.add(s);
    stars.push({ mesh: s, vel: v, life: 1.0 });
  }
}

// â”€â”€ Sling / David indicator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const slingGroup = new THREE.Group();
scene.add(slingGroup);
// Simple sling handle at bottom center
const slingBase = makeMesh(new THREE.CylinderGeometry(0.15, 0.15, 0.6, 8), 0x8B6914);
slingBase.position.set(0, 0.3, 12);
slingGroup.add(slingBase);

// â”€â”€ Aim arrow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const arrowGeo = new THREE.ConeGeometry(0.18, 0.7, 8);
const arrowMat = new THREE.MeshBasicMaterial({ color: 0x2ec4b6, transparent: true, opacity: 0.85 });
const arrow = new THREE.Mesh(arrowGeo, arrowMat);
arrow.visible = false;
scene.add(arrow);

// â”€â”€ Stone (projectile) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const stoneGeo = new THREE.DodecahedronGeometry(0.28, 0);
const stoneMat = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
const stone = new THREE.Mesh(stoneGeo, stoneMat);
stone.castShadow = true;
stone.visible = false;
scene.add(stone);

// â”€â”€ Trajectory dots â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const dotPool = [];
for (let i = 0; i < 10; i++) {
  const d = new THREE.Mesh(
    new THREE.SphereGeometry(0.1, 6, 6),
    new THREE.MeshBasicMaterial({ color: 0x2ec4b6, transparent: true, opacity: 0.5 })
  );
  d.visible = false;
  scene.add(d);
  dotPool.push(d);
}

// â”€â”€ Audio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const hitSound = new Audio('hit_ouch.wav');

// â”€â”€ Game state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let score = 0, stonesLeft = 5;
let stoneInFlight = false;
let stonePos, stoneVel;
let goliathHit = false, goliathFallAngle = 0;
let isDragging = false, dragStart = null, dragCurrent = null;
let gameOver = false;

const scoreEl = document.getElementById('score-val');
const stonesEl = document.getElementById('stones-val');
const msgEl = document.getElementById('msg');
const msgTitle = document.getElementById('msg-title');
const msgBody = document.getElementById('msg-body');
const restartBtn = document.getElementById('restart');
const hintEl = document.getElementById('aim-hint');

function updateUI() {
  scoreEl.textContent = score;
  stonesEl.textContent = stonesLeft;
}

// Convert pointer event to normalized coords
function getPointer(e) {
  const t = e.touches ? e.touches[0] : e;
  return { x: t.clientX / W, y: t.clientY / H };
}

// Compute launch velocity from drag
function computeVelocity(start, current) {
  const dx = (current.x - start.x) * 28;
  const dy = -(current.y - start.y) * 28;
  // horizontal aim maps to x, vertical drag maps to y/z
  const vx = dx;
  const vy = Math.max(4, dy + 6);
  const vz = -18 - Math.abs(dy) * 0.5;
  return new THREE.Vector3(vx, vy, vz);
}

function launchStone(vel) {
  if (stoneInFlight || stonesLeft <= 0 || gameOver) return;
  stonesLeft--;
  updateUI();
  stonePos = new THREE.Vector3(0, 1.5, 12);
  stoneVel = vel.clone();
  stone.position.copy(stonePos);
  stone.visible = true;
  stoneInFlight = true;
  hintEl.style.display = 'none';
  dotPool.forEach(d => d.visible = false);
  arrow.visible = false;
}

function showTrajectory(start, cur) {
  const vel = computeVelocity(start, cur);
  let p = new THREE.Vector3(0, 1.5, 12);
  const g = new THREE.Vector3(0, -12, 0);
  const dt = 0.08;
  let v = vel.clone();
  dotPool.forEach((d, i) => {
    for (let s = 0; s < 3; s++) {
      v.addScaledVector(g, dt);
      p = p.clone().addScaledVector(v, dt);
    }
    d.position.copy(p);
    d.visible = p.y > 0 && p.z > -20;
  });
  // Arrow direction
  arrow.visible = true;
  arrow.position.set(0, 2.5, 12);
  const dir = vel.clone().normalize();
  arrow.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
}

// Pointer handlers
function onDown(e) {
  if (stoneInFlight || gameOver) return;
  isDragging = true;
  dragStart = getPointer(e);
  dragCurrent = { ...dragStart };
  e.preventDefault();
}
function onMove(e) {
  if (!isDragging) return;
  dragCurrent = getPointer(e);
  showTrajectory(dragStart, dragCurrent);
  e.preventDefault();
}
function onUp(e) {
  if (!isDragging) return;
  isDragging = false;
  dotPool.forEach(d => d.visible = false);
  arrow.visible = false;
  if (dragStart && dragCurrent) {
    const dist = Math.hypot(dragCurrent.x - dragStart.x, dragCurrent.y - dragStart.y);
    if (dist > 0.01) launchStone(computeVelocity(dragStart, dragCurrent));
  }
  dragStart = dragCurrent = null;
}

renderer.domElement.addEventListener('mousedown', onDown);
renderer.domElement.addEventListener('mousemove', onMove);
renderer.domElement.addEventListener('mouseup', onUp);
renderer.domElement.addEventListener('touchstart', onDown, { passive: false });
renderer.domElement.addEventListener('touchmove', onMove, { passive: false });
renderer.domElement.addEventListener('touchend', onUp, { passive: false });

// â”€â”€ Collision check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkHit() {
  const gp = goliathGroup.position;
  const dx = Math.abs(stone.position.x - gp.x);
  const dy = stone.position.y - gp.y;
  const dz = Math.abs(stone.position.z - gp.z);
  return dx < 1.4 && dy > 0.5 && dy < 5.5 && dz < 1.5;
}

function onHit() {
  score += 100;
  updateUI();
  goliathHit = true;
  hitSound.currentTime = 0;
  hitSound.play();
  stoneInFlight = false;
  stone.visible = false;
  spawnStars(stone.position.clone());
  // Reset stone after delay
  setTimeout(() => {
    if (!gameOver) resetGoliath();
  }, 1800);
}

function resetGoliath() {
  goliathHit = false;
  goliathFallAngle = 0;
  goliathGroup.rotation.z = 0;
  goliathGroup.position.x = (Math.random()-0.5)*6;
  goliathGroup.position.z = -10 - Math.random()*4;
}

function checkGameOver() {
  if (stonesLeft <= 0 && !stoneInFlight && !goliathHit) {
    gameOver = true;
    let msg = '';
    if (score === 0) msg = 'Keep practicing, David!';
    else if (score < 300) msg = 'Good effort, brave warrior!';
    else if (score < 600) msg = 'Great aim, David!';
    else msg = 'You defeated Goliath! ğŸ‰';
    msgTitle.textContent = score >= 300 ? 'â­ Great Job! â­' : 'ğŸª¨ Game Over!';
    msgBody.textContent = `Final Score: ${score}  |  ${msg}`;
    msgEl.style.display = 'block';
    restartBtn.style.display = 'block';
  }
}

function restartGame() {
  score = 0; stonesLeft = 5;
  gameOver = false; stoneInFlight = false;
  goliathHit = false; goliathFallAngle = 0;
  goliathGroup.rotation.z = 0;
  goliathGroup.position.set(0, 0, -10);
  stone.visible = false;
  stars.forEach(s => scene.remove(s.mesh));
  stars.length = 0;
  msgEl.style.display = 'none';
  restartBtn.style.display = 'none';
  hintEl.style.display = 'block';
  updateUI();
}

// Goliath side-to-side bob
let bobT = 0;

// â”€â”€ Clouds â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const clouds = [];
for (let i = 0; i < 6; i++) {
  const cg = new THREE.Group();
  [0, 0.6, -0.5].forEach((ox, ci) => {
    const s = 1.2 + ci * 0.4;
    const sphere = new THREE.Mesh(
      new THREE.SphereGeometry(s, 10, 8),
      new THREE.MeshLambertMaterial({ color: 0xffffff })
    );
    sphere.position.set(ox * 2, ci * 0.3, 0);
    cg.add(sphere);
  });
  cg.position.set((Math.random()-0.5)*80, 18+Math.random()*8, -30-Math.random()*20);
  scene.add(cg);
  clouds.push({ group: cg, speed: 0.02 + Math.random()*0.02 });
}

// â”€â”€ Animation loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  // Clouds drift
  clouds.forEach(c => {
    c.group.position.x += c.speed;
    if (c.group.position.x > 60) c.group.position.x = -60;
  });

  // Goliath bob
  if (!goliathHit) {
    bobT += dt;
    goliathGroup.position.x += Math.sin(bobT * 1.2) * 0.015;
    goliathGroup.rotation.y = Math.sin(bobT * 0.7) * 0.15;
  }

  // Goliath fall on hit
  if (goliathHit && goliathFallAngle < Math.PI/2) {
    goliathFallAngle += dt * 2.5;
    goliathGroup.rotation.z = goliathFallAngle;
    goliathGroup.position.y = -Math.sin(goliathFallAngle) * 0.5;
  }


  // Stone flight
  if (stoneInFlight) {
    stoneVel.y -= 18 * dt;
    stonePos.addScaledVector(stoneVel, dt);
    stone.position.copy(stonePos);
    stone.rotation.x += dt * 8;
    stone.rotation.y += dt * 5;

    if (checkHit()) {
      onHit();
    } else if (stonePos.y < 0 || stonePos.z < -30 || Math.abs(stonePos.x) > 20) {
      stoneInFlight = false;
      stone.visible = false;
      setTimeout(() => { if (!gameOver) checkGameOver(); }, 300);
    }
  } else if (!goliathHit && !gameOver && stonesLeft === 0) {
    checkGameOver();
  }

  // Stars
  for (let i = stars.length - 1; i >= 0; i--) {
    const s = stars[i];
    s.vel.y -= 12 * dt;
    s.mesh.position.addScaledVector(s.vel, dt);
    s.life -= dt * 1.2;
    s.mesh.material.opacity = Math.max(0, s.life);
    s.mesh.material.transparent = true;
    if (s.life <= 0) { scene.remove(s.mesh); stars.splice(i, 1); }
  }

  renderer.render(scene, camera);
}
animate();
updateUI();
</script>
</body>
</html>